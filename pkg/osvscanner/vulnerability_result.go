package osvscanner

import (
	"fmt"
	"sort"

	"github.com/google/osv-scanner/internal/output"
	"github.com/google/osv-scanner/internal/sourceanalysis"
	"github.com/google/osv-scanner/pkg/grouper"
	"github.com/google/osv-scanner/pkg/models"
	"github.com/google/osv-scanner/pkg/osv"
)

// Function used to filter vulnerabilities and groups.
type vulnFilterFn func(sourcePath string, vulns []models.Vulnerability, groups []models.GroupInfo) ([]models.Vulnerability, []models.GroupInfo)

// groupResponseBySource converts raw OSV API response into structured vulnerability information
// grouped by source location.
func groupResponseBySource(r *output.Reporter, query osv.BatchedQuery, resp *osv.HydratedBatchedResponse, callAnalysis bool, filter vulnFilterFn) models.VulnerabilityResults {
	output := models.VulnerabilityResults{
		Results: []models.PackageSource{},
	}
	groupedBySource := map[models.SourceInfo][]models.PackageVulns{}

	totalFiltered := 0

	for i, query := range query.Queries {
		vulns := resp.Results[i].Vulns
		vulnCount := len(vulns)
		groups := grouper.Group(grouper.ConvertVulnerabilityToIDAliases(vulns))
		vulns, groups = filter(query.Source.Path, vulns, groups)
		totalFiltered += vulnCount - len(vulns)
		if len(vulns) == 0 {
			continue
		}
		var pkg models.PackageVulns
		if query.Commit != "" {
			pkg.Package.Version = query.Commit
			pkg.Package.Ecosystem = "GIT"
		} else if query.Package.PURL != "" {
			var err error
			pkg.Package, err = PURLToPackage(query.Package.PURL)
			if err != nil {
				r.PrintError(fmt.Sprintf("Failed to parse purl: %s, with error: %s",
					query.Package.PURL, err))

				continue
			}
		} else {
			pkg = models.PackageVulns{
				Package: models.PackageInfo{
					Name:      query.Package.Name,
					Version:   query.Version,
					Ecosystem: query.Package.Ecosystem,
				},
			}
		}

		pkg.Vulnerabilities = vulns
		pkg.Groups = groups
		groupedBySource[query.Source] = append(groupedBySource[query.Source], pkg)
	}

	if totalFiltered > 0 {
		r.PrintText(fmt.Sprintf("Filtered %d vulnerabilities from output\n", totalFiltered))
	}

	for source, packages := range groupedBySource {
		if callAnalysis {
			sourceanalysis.Run(r, source, packages)
		}
		output.Results = append(output.Results, models.PackageSource{
			Source:   source,
			Packages: packages,
		})
	}

	sort.Slice(output.Results, func(i, j int) bool {
		if output.Results[i].Source.Path == output.Results[j].Source.Path {
			return output.Results[i].Source.Type < output.Results[j].Source.Type
		}

		return output.Results[i].Source.Path < output.Results[j].Source.Path
	})

	return output
}
