package osvscanner

import (
	"fmt"
	"sort"
	"strings"

	"github.com/google/osv-scanner/internal/sourceanalysis"
	"github.com/google/osv-scanner/pkg/grouper"
	"github.com/google/osv-scanner/pkg/models"
	"github.com/google/osv-scanner/pkg/osv"
	"github.com/google/osv-scanner/pkg/reporter"
)

// buildVulnerablityResults takes the responses from the OSV API and the deps.dev API
// and converts this into a VulnerabilityResults. As part is this, it groups
// vulnerability information by source location.
// TODO: This function is getting long, we should refactor it
func buildVulnerabilityResults(
	r reporter.Reporter,
	packages []scannedPackage,
	vulnsResp *osv.HydratedBatchedResponse,
	licensesResp [][]models.License,
	callAnalysis bool,
	allPackages bool,
	licenses bool,
	licensesAllowlist []string,
) models.VulnerabilityResults {
	output := models.VulnerabilityResults{
		Results: []models.PackageSource{},
	}
	groupedBySource := map[models.SourceInfo][]models.PackageVulns{}
	if len(licensesAllowlist) == 1 && licensesAllowlist[0] == "" {
		licensesAllowlist = []string{}
	}

	for i, rawPkg := range packages {
		includePackage := allPackages
		var pkg models.PackageVulns
		if rawPkg.Commit != "" {
			pkg.Package.Commit = rawPkg.Commit
			pkg.Package.Name = rawPkg.Name
			// pkg.Package.Ecosystem = "GIT"
		} else if rawPkg.PURL != "" {
			var err error
			pkg.Package, err = models.PURLToPackage(rawPkg.PURL)
			if err != nil {
				r.PrintError(fmt.Sprintf("Failed to parse purl: %s, with error: %s",
					rawPkg.PURL, err))

				continue
			}
		} else {
			pkg.Package = models.PackageInfo{
				Name:      rawPkg.Name,
				Version:   rawPkg.Version,
				Ecosystem: string(rawPkg.Ecosystem),
			}
		}

		if len(vulnsResp.Results[i].Vulns) > 0 {
			includePackage = true
			pkg.Vulnerabilities = vulnsResp.Results[i].Vulns
			pkg.Groups = grouper.Group(grouper.ConvertVulnerabilityToIDAliases(pkg.Vulnerabilities))
		}
		if licenses {
			pkg.Licenses = licensesResp[i]
			allowlist := make(map[string]bool)
			for _, license := range licensesAllowlist {
				allowlist[strings.ToLower(license)] = true
			}
			for _, license := range pkg.Licenses {
				if !allowlist[strings.ToLower(string(license))] {
					pkg.LicenseViolations = append(pkg.LicenseViolations, license)
				}
			}
			if len(pkg.LicenseViolations) > 0 {
				includePackage = true
			}
		}
		if includePackage {
			groupedBySource[rawPkg.Source] = append(groupedBySource[rawPkg.Source], pkg)
		}
	}

	for source, packages := range groupedBySource {
		if callAnalysis {
			sourceanalysis.Run(r, source, packages)
		}
		output.Results = append(output.Results, models.PackageSource{
			Source:   source,
			Packages: packages,
		})
	}

	sort.Slice(output.Results, func(i, j int) bool {
		if output.Results[i].Source.Path == output.Results[j].Source.Path {
			return output.Results[i].Source.Type < output.Results[j].Source.Type
		}

		return output.Results[i].Source.Path < output.Results[j].Source.Path
	})

	if licenses {
		output.ExperimentalAnalysisConfig.Licenses.Enabled = true
		allowlist := make([]models.License, len(licensesAllowlist))
		for i, l := range licensesAllowlist {
			allowlist[i] = models.License(l)
		}
		output.ExperimentalAnalysisConfig.Licenses.Allowlist = allowlist
	}
	if callAnalysis {
		output.ExperimentalAnalysisConfig.CallAnalysis.Enabled = true
	}

	return output
}

// grouped by source location.
func groupBySource(r reporter.Reporter, packages []scannedPackage) models.VulnerabilityResults {
	output := models.VulnerabilityResults{
		Results: []models.PackageSource{},
	}
	groupedBySource := map[models.SourceInfo][]models.PackageVulns{}

	for _, p := range packages {
		var pkg models.PackageVulns
		switch {
		case p.Ecosystem != "" && p.Name != "" && p.Version != "":
			pkg = models.PackageVulns{
				Package: models.PackageInfo{
					Name:      p.Name,
					Version:   p.Version,
					Ecosystem: string(p.Ecosystem),
				},
			}
		case p.Commit != "":
			pkg.Package.Version = p.Commit
			pkg.Package.Ecosystem = "GIT"
		case p.PURL != "":
			var err error
			pkg.Package, err = models.PURLToPackage(p.PURL)
			if err != nil {
				r.PrintError(fmt.Sprintf("Failed to parse purl: %s, with error: %s", p.PURL, err))
				continue
			}
		default:
			r.PrintError(fmt.Sprintf("package %v does not have a commit, PURL or ecosystem/name/version identifier", p))
			continue
		}

		pkg.Vulnerabilities = nil

		pkg.Groups = grouper.Group(grouper.ConvertVulnerabilityToIDAliases(pkg.Vulnerabilities))
		groupedBySource[p.Source] = append(groupedBySource[p.Source], pkg)
	}

	for source, packages := range groupedBySource {
		output.Results = append(output.Results, models.PackageSource{
			Source:   source,
			Packages: packages,
		})
	}

	return output
}
