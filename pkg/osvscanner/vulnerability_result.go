package osvscanner

import (
	"fmt"
	"path/filepath"

	"github.com/google/osv-scanner/internal/govulncheckshim"
	"github.com/google/osv-scanner/internal/output"
	"github.com/google/osv-scanner/pkg/grouper"
	"github.com/google/osv-scanner/pkg/models"
	"github.com/google/osv-scanner/pkg/osv"
)

// groupResponseBySource converts raw OSV API response into structured vulnerability information
// grouped by source location.
func groupResponseBySource(r *output.Reporter, query osv.BatchedQuery, resp *osv.HydratedBatchedResponse, callAnalysis bool) models.VulnerabilityResults {
	output := models.VulnerabilityResults{
		Results: []models.PackageSource{},
	}
	groupedBySource := map[models.SourceInfo][]models.PackageVulns{}
	vulnBySource := map[models.SourceInfo][]models.Vulnerability{}
	groupsByIDBySource := map[models.SourceInfo]map[string]*models.GroupInfo{}

	for i, query := range query.Queries {
		response := resp.Results[i]
		if len(response.Vulns) == 0 {
			continue
		}
		var pkg models.PackageVulns
		if query.Commit != "" {
			pkg.Package.Version = query.Commit
			pkg.Package.Ecosystem = "GIT"
		} else if query.Package.PURL != "" {
			var err error
			pkg.Package, err = PURLToPackage(query.Package.PURL)
			if err != nil {
				r.PrintError(fmt.Sprintf("Failed to parse purl: %s, with error: %s",
					query.Package.PURL, err))

				continue
			}
		} else {
			pkg = models.PackageVulns{
				Package: models.PackageInfo{
					Name:      query.Package.Name,
					Version:   query.Version,
					Ecosystem: query.Package.Ecosystem,
				},
			}
		}

		pkg.Vulnerabilities = response.Vulns

		if groupsByIDBySource[query.Source] == nil {
			groupsByIDBySource[query.Source] = make(map[string]*models.GroupInfo)
		}

		groups := grouper.Group(grouper.ConvertVulnerabilityToIDAliases(pkg.Vulnerabilities))
		// TODO(rex): Is there a better way to do this, this feels fragile
		for i := range groups {
			for _, id := range groups[i].IDs {
				groupsByIDBySource[query.Source][id] = &groups[i]
			}
		}
		pkg.Groups = groups
		groupedBySource[query.Source] = append(groupedBySource[query.Source], pkg)
		vulnBySource[query.Source] = append(vulnBySource[query.Source], pkg.Vulnerabilities...)
	}

	if callAnalysis {
		for si, v := range vulnBySource {
			if si.Type == "lockfile" && filepath.Base(si.Path) == "go.mod" {
				res, err := govulncheckshim.RunVulnCheck(filepath.Dir(si.Path), v)
				if err != nil {
					r.PrintError("Failed to run govulncheck on " + si.Path)
					continue
				}
				for _, v := range res.Vulns {
					analysis := &groupsByIDBySource[si][v.OSV.ID].Analysis
					if *analysis == nil {
						*analysis = make(map[string]models.AnalysisInfo)
					}
					(*analysis)[v.OSV.ID] = models.AnalysisInfo{
						Called: v.IsCalled(),
					}
				}
			}
		}
	}

	for source, packages := range groupedBySource {
		output.Results = append(output.Results, models.PackageSource{
			Source:   source,
			Packages: packages,
		})
	}

	return output
}
