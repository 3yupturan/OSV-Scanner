package osvscanner

import (
	"fmt"
	"sort"

	"github.com/google/osv-scanner/internal/sourceanalysis"
	"github.com/google/osv-scanner/pkg/grouper"
	"github.com/google/osv-scanner/pkg/models"
	"github.com/google/osv-scanner/pkg/osv"
	"github.com/google/osv-scanner/pkg/reporter"
	"golang.org/x/exp/slices"
)

// groupResponseBySource converts raw OSV API response into structured vulnerability information
// grouped by source location.
func groupResponseBySource(r reporter.Reporter, query osv.BatchedQuery, resp *osv.HydratedBatchedResponse, callAnalysis bool) models.VulnerabilityResults {
	output := models.VulnerabilityResults{
		Results: []models.PackageSource{},
	}
	groupedBySource := map[models.SourceInfo][]models.PackageVulns{}

	for i, query := range query.Queries {
		response := resp.Results[i]
		if len(response.Vulns) == 0 {
			continue
		}
		var pkg models.PackageVulns
		if query.Commit != "" {
			pkg.Package.Version = query.Commit
			pkg.Package.Ecosystem = "GIT"
		} else if query.Package.PURL != "" {
			var err error
			pkg.Package, err = PURLToPackage(query.Package.PURL)
			if err != nil {
				r.PrintError(fmt.Sprintf("Failed to parse purl: %s, with error: %s",
					query.Package.PURL, err))

				continue
			}
		} else {
			pkg = models.PackageVulns{
				Package: models.PackageInfo{
					Name:      query.Package.Name,
					Version:   query.Version,
					Ecosystem: query.Package.Ecosystem,
				},
			}
		}

		pkg.Vulnerabilities = response.Vulns

		groups := grouper.Group(grouper.ConvertVulnerabilityToIDAliases(pkg.Vulnerabilities))
		pkg.Groups = groups
		groupedBySource[query.Source] = append(groupedBySource[query.Source], pkg)
	}

	for source, packages := range groupedBySource {
		if callAnalysis {
			sourceanalysis.Run(r, source, packages)
		}
		output.Results = append(output.Results, models.PackageSource{
			Source:   source,
			Packages: packages,
		})
	}

	sort.Slice(output.Results, func(i, j int) bool {
		if output.Results[i].Source.Path == output.Results[j].Source.Path {
			return output.Results[i].Source.Type < output.Results[j].Source.Type
		}

		return output.Results[i].Source.Path < output.Results[j].Source.Path
	})

	return output
}

// diffVulnerabilityResults will return any new vulnerabilities that are in `newRes`
// which is not present in `oldRes`, but not the reverse.
//
// Current implementation is O(n^2) on the number of vulns, but can be reduced to linear time
func diffVulnerabilityResults(oldRes, newRes models.VulnerabilityResults) models.VulnerabilityResults {
	result := models.VulnerabilityResults{}
	for _, ps := range newRes.Results {
		sourceIdx := slices.IndexFunc(oldRes.Results, func(elem models.PackageSource) bool { return elem.Source == ps.Source })
		if sourceIdx == -1 {
			result.Results = append(result.Results, ps)
			continue
		}
		result.Results = append(result.Results, models.PackageSource{
			Source: ps.Source,
		})
		resultPS := &result.Results[len(result.Results)-1]
		for _, pv := range ps.Packages {
			pkgs := oldRes.Results[sourceIdx].Packages
			pkgIdx := slices.IndexFunc(pkgs, func(elem models.PackageVulns) bool { return elem.Package == pv.Package })
			if pkgIdx == -1 {
				resultPS.Packages = append(resultPS.Packages, pv)
				continue
			}
			// Only copy over packages as vulns and groups might change
			resultPS.Packages = append(resultPS.Packages, models.PackageVulns{
				Package: pv.Package,
			})
			resultPV := &resultPS.Packages[len(resultPS.Packages)-1]
			for _, v := range pv.Vulnerabilities {
				vulns := pkgs[pkgIdx].Vulnerabilities
				vulnIdx := slices.IndexFunc(vulns, func(elem models.Vulnerability) bool { return elem.ID == v.ID })
				if vulnIdx == -1 {
					resultPV.Vulnerabilities = append(resultPV.Vulnerabilities, v)
					continue
				}
			}
			if len(resultPV.Vulnerabilities) == 0 {
				// No vulns, so we can remove the PackageVulns entry entirely, and skip grouping
				resultPS.Packages = resultPS.Packages[:len(resultPS.Packages)-1]
				continue
			}
			// Rebuild the groups lost in the previous step
			groups := grouper.Group(grouper.ConvertVulnerabilityToIDAliases(resultPV.Vulnerabilities))
			resultPV.Groups = groups
		}
		if len(resultPS.Packages) == 0 {
			// No packages, so we can remove the PackageSource entry entirely
			result.Results = result.Results[:len(result.Results)-1]
			continue
		}
	}

	return result
}
